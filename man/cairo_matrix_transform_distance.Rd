% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cairo-matrix.R
\name{cairo_matrix_transform_distance}
\alias{cairo_matrix_transform_distance}
\title{cairo_matrix_transform_distance}
\usage{
cairo_matrix_transform_distance(matrix, dx, dy)
}
\arguments{
\item{matrix}{[\code{cairo_matrix_t *}] a #cairo_matrix_t}

\item{dx}{[\code{double *}] X component of a distance vector. An in/out parameter}

\item{dy}{[\code{double *}] Y component of a distance vector. An in/out parameter}
}
\description{
Transforms the distance vector (dx,dy) by matrix. This is
similar to cairo_matrix_transform_point() except that the translation
components of the transformation are ignored. The calculation of
the returned vector is as follows:
}
\details{
<programlisting>
dx2 = dx1 * a + dy1 * c;
dy2 = dx1 * b + dy1 * d;
</programlisting>

Affine transformations are position invariant, so the same vector
always transforms to the same vector. If (x1,y1) transforms
to (x2,y2) then (x1+dx1,y1+dy1) will transform to
(x1+dx2,y1+dy2) for all values of x1 and x2.

Since: 1.0

C function prototype: \code{void cairo_matrix_transform_distance (const cairo_matrix_t *matrix, double *dx, double *dy)}
}
\seealso{
Other cairo-matrix: 
\code{\link{cairo_matrix_init_rotate}()},
\code{\link{cairo_matrix_init_scale}()},
\code{\link{cairo_matrix_init_translate}()},
\code{\link{cairo_matrix_init}()},
\code{\link{cairo_matrix_invert}()},
\code{\link{cairo_matrix_multiply}()},
\code{\link{cairo_matrix_rotate}()},
\code{\link{cairo_matrix_scale}()},
\code{\link{cairo_matrix_transform_point}()},
\code{\link{cairo_matrix_translate}()}
}
\concept{cairo-matrix}
